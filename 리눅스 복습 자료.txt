1. ubuntu server down> option 2번째  > 20.04  // 안봐도됨

1. 쉘(Shell) : 사용자/프로그램과 커널(Kernel)을 유연하고 안전하게 연결해주는 역활.
(zsh, csh, bash 등 종류 많음, 우리는 Bash Shell 사용)

2. 명령줄(Command Line) : 쉘이 사용자로부터 명령을 받기 위한 체계. (Bash Shell은) 아래의 구조를 가진다
   ubuntu         @study :            ~ $ 
 (Username)      (기기이름:Domain)     (현재 위치)
 (사용자 이름)                          (PWD)


3. 디렉토리(Directory) : 파일/디렉토리를 담을 수 있는 공간. 폴더(Folder)라고 부르지 않는다.
다만 역활은 같다.

4. 홈 디렉토리(Home Directory) : 로그인한 사용자의 "내 문서" 같은 느낌의 공간이다.
로그인한 사용자의 이름에 따라 경로가 달라지고 경로는 "/home/<사용자 이름>/"이며, 주로 물결표(~)
로 축약하여 사용한다.

5. 루트 디렉토리(Root Directory) : 최상위 디렉토리. 레터링을 통한 파티션 구분이 있는 윈도우와
달리, 우분투 에는 그런 부분이 없음으로, 루트 디렉토리 보다 상위 디렉토리는 존재하지 않는다.
경로는 항상 "/"이며, 이는 절대 경로(Absolute Path)이다.
  /bin : (시스템 구동에 필요한) 실행 파일들이 위치하고 있다.
  /boot : 커널(Kernal) 이미지 파일 및 부팅 정보 등이 위치하고 있다.
  /dev : 연결된 장치(Device) 정보가 위치하고 있다.
  /etc : 시스템 및 일반 패키지의 설정 파일 등이 위치하고 있다.
  /home : 사용자 계정 별 홈 디렉토리를 포함하고 있다.
  /media : CD나 USB등 외부 저장장치를 이용하기 위해 존재한다.
  /mnt : 마운트(Mount). CD나 DVD등 외부 저장장치를 수동으로 이용하기 위해 존재한다. (오래됨)
  /root : root 계정의 홈 디렉토리. (/home/root 아님)
  /sbin : root 계정으로만 실행할 수 잇는 실행 파일들이 위치하고 있다.
  /sys : 커널(Kernel) 정보가 들어 있다.
  /tmp : 운영체제 구동 중에 발생하는 임시 파일(Temporary File)이 저장된다. 부팅시 내부 내용이 초기화됨.
  /usr : 일반 실행 파일이 위치. 라이브러리, 헤더 등.
  /var : 일반 데이터 파일 및 로그가 저장되는 곳.

6. 절대 경로(Absolute Path) : 루트 디렉토리 부터 명시한 경로. "/var/www/html"및 
"/etc/ssh" 등은 절대 경로이고, 가령 "vi sshd_config" 라고 적게 되면 이는 "sshd_config"\
파일에 대한 상대 경로(Relative Path)이다.

7. 상대 경로(Relative Path) : 슬래쉬(/)로 시작하지 않는 경로. 현재 작업 중인 위치를 기준으로 
풀이한다. 
   - 가령 현재 작업 중인 위치가 "~" 일때, "vi memo" 명령 실행 시 "memo" 파일의 전체 경로는 
"/home/ubuntu/memo"가 된다.
   - 하지만 현재 작업 중인 위치와 무관하게, (권한 문제가 없다는 가정하에) "vi /memo" 명령 실행
시 "memo" 파일의 전체 경로는 "/memo"가 된다. 
   - 즉, 절대 경로와 상대 경로를 명시할 때, 메모 파일이 생성 되는 위치가 완전히 달라진다.

8. 현재 디렉토리(Current Directory) : 마침표(.) 특수기호는 항상 현재 디렉토리를 가르킨다.

9. 상위 디렉토리(Parent Directory) : 마침표 두 개(..) 특수기호는 항상 현재 디렉토리를 가리킨다.
가령 "cd.."명령어는 작업 디렉토리의 위치를 현재 디렉토리의 상위 디렉토리로 변경한다. 현재 작업 
디렉토리가 "~" 일때, "cd .." 명령을 이행하면 작업 디렉토리가 "/home"으로 변경된다("~"는 /home/ubuntu 임으로).

10. CD(Change Directory) 명령어 : 현재 작업 디렉토리를 변경하기 위해 사용한다. "cd <원하는 경로>" 방식으로
사용한다. 가령 "cd /" 혹은 "cd scripts" 등.

11. PWD(Present Working Directory) 명령어 : 현재 작업 디렉토리의 (절대)경로를 출력한다.
  ubuntu@study:~$ pwd
  /home/ubuntu/

12. Man(Manual) 명령어 : (지원하는 경우에 한해) 다른 명령어의 메뉴얼을 조회한다. "man <명령어>"
방식으로 사용. 가령 "man ls".

13. LS(List) 명령어 : 어떠한 디렉토리 내부의 파일 및 디렉토리 목록을 표시하기 위해 사용한다. 
"ls <경로?>" 방식으로 사용. 단, <경로>가 생략될 경우 현재 작업 디렉토리를 기준으로 한다.
 * 매개변수 *
 -a 혹은 --all : 파일 혹은 디렉토리의 이름이 마침표(.)로 시작하는 숨김 상태여도 표시한다.
 -l : 목록의 단순 나열이 아닌 표(Table)로 정리하여 출력한다.
 -R 혹은 --recursive : 명령 대상이 되는 디렉토리의 내용 뿐 아니라 이가 가지는 디렉토리 혹은 그
아래의 모든 내용 까지 표시한다.

14. MKDIR(Make Directory) 명령어 : 디렉토리를 만들기 위해 사용한다. "mkdir <디렉토리 경로>"
방식으로 사용. "mkdir scripts" 혹은 "mkdir /home/ubuntu/scripts" 처럼 사용한다.

15. RMDIR(Remove Directory) 명령어 : 비어있는 디렉토리를 삭제하기 위해 사용한다. "rmdir
<디렉토리 경로>" 방식으로 사용.

16. RM(Remove) 명령어 : 파일 혹은 디렉토리를 삭제하기 위해 사용한다. "rm <매개변수?> <경로|패턴>" 방식으로 사용.
가령 "rm -rf *" 등.
 * 일부 매개변수 *
 -f 혹은 --force : 대상으로 하는 경로나 패턴에 일치하는 파일이나 디렉토리가 없다고 하더라도 경고나 오류를 표시하지 않고 무시한다.
 -r 혹은 -R 혹은 --recursive : 만약 대상으로 하는 디렉토리가 비어있지 않다면 해당 디렉토리의 내용 부터 삭제한 뒤 해당 디렉
토리를 삭제한다.

17. CP(Copy) 명령어 : 파일 혹은 디렉토리를 다른 위치로 복사하기 위해 사용한다.
  * 사용 패턴 *
  cp <대상 파일> <붙여넣고자 하는 파일 경로> 
    => cp <a> <b> 에서 a파일이 b파일로 복사된다.
  cp <대상 파일> <붙여넣고자 하는 디렉토리 경로>
    => cp <a> <b> 에서 a파일(들)이 b디렉토리로 복사된다.

cp memo ./temp/memo  cp <대상 파일> <붙여넣고자 하는 파일 경로> 
cp memo ./temp       cp <대상 파일> <붙여넣고자 하는 디렉토리 경로>
 

18. MV(Move) 명령어 : 파일 혹은 디렉토리의 이름을 변경하거나 다른 위치로 이동하기 위해 사용한다.
 * 사용 패턴 *
 mv <대상 경로> <이동하고자 하는 경로>
 => "mv <a> <b>" 에서 a가 b로 이동된다.
 mv <대상 경로...> <이동하고자 하는 디렉토리 경로> 
 => "mv <a...> <b>" 에서 a(들)이 b디렉토리로 이동한다.

 * 일부 매개변수 * 
  -r 혹은 -R 혹은 --recursive : 디렉토리의 내부 내용을 포함하여 복사한다.

19. CAT(Catenate) 명령어 : 파일의 내용을 출력하기 위해 사용한다. "cat <매개변수?> <파일 경로>" 방식으로 사용.
 
 * 일부 매개변수 *
 -n 혹은 --number : 줄 수를 표시함.

20. TAIL 명령어 : 파일의 뒷 부분 내용을 출력하기 위해 사용한다. "tail <매개변수?> <파일 경로>" 방식으로 사용.

 * 일부 매개변수 *
 -n 혹은 --lines : 줄 수를 설정함. (기본 값 10)

21. CHOWN(Change Ownership) : 파일이나 디렉토리의 소유자/소유그룹을 변경하기 위해 사용한다. "chown <매개변수?>
<소유자>:<소유 그룹> <대상 파일 혹은 디렉토리...>" 형식으로 사용한다. 가령 "memo"파일의 소유자를 "a"로, 소유 그룹을 "b"로 변경하기
위해서 다음과 같이 명령한다. "chown a:b memo"
 
 * 일부 매개변수 * 
 -R 혹은 --recursive : 대상이 디렉토리 일때, 이가 포함하는 하위 파일 및 디렉토리 전체의 소유자/소유그룹도 함께 변경한다.

22. CHMOD(Change Mode) : 파일이나 디렉토리에 대한 접근 권한을 변경하기 위해 사용한다 "chmod <매개변수?> <모드|8진법 모드>
<대상 파일 혹은 디렉토리...>" 형식으로 사용한다. 가령 "memo" 파일에 소유자에게 쓰기 권한을 부여하기 위해서는 다음과 같이 명령한다.
"chmod u+rw,g+r memo"
 
 * 일부 매개변수 * 
 -R 혹은 --recursive : 대상이 디렉토리 일때, 이가 포함하는 하위 파일 및 디렉토리 전체의 소유자/소유그룹도 함께 변경한다.

23. 권한의 주체 : 리눅스에서 권한의 주체는 크게 세 대상으로 나누어진다. 소유자, 소유그룹, 기타.

24. 권한 : 특정 대상에 대한 특정 권한의 부여 및 회수는 다음과 같은 형식이다. "<대상><부여|회수|설정><권한...>"
  * 대상 *
  소유자 : u
  소유 그룹 : g
  기타 : o
  * 부여|회수 *
  부여 : +
  회수 : -
  * 권한 *
  읽기 : r
  쓰기 : w
  실행 : x

25. 8진법 권한(Octal Mode) : 세 주체에 대한 권한을 8진법을 이용하여 세 자리로 표현하는 방식. 표현 "abc"에서 a는 소유자의 권한, b는 
소유그룹의 권한, c는 기타의 권한을 의미한다.

 * 값  : 아래 권한 값은 대상이 되는 권한 값 미만 값들의 합에 해당한다 *
 0 : 권한 없음
 1 : 실행
 2 : 쓰기
(3 : 1 + 2, 실행 + 쓰기)
 4. 읽기
(5 : 1 + 4, 실행 + 읽기)
(6 : 2 + 4, 쓰기 + 읽기)
(7 : 1 + 2 + 4, 실행 + 쓰기 + 읽기, 모든 권한)

 
26. 권한 변환 : u+rwx,g+rw,o-rwx 는 8진법으로 760과 같다.

27. SUDO(Superuser Do) 명령어 : 최고 관리자 권한으로 실행한다. "sudo <명령어>"의 형태로 사용한다.

28. APT(Advanced Packaging Tool) 명령어 : 시스템에 새로운 소프트웨어를 설치하거나, 기존에 설치되어 있는 소프트웨어를 관리하기 위해
사용한다. "apt <명령어> <패키지?>" 형식으로 사용한다.
 * 명령어 *
 update : 모든 가용 패키지의 정보를 새롭게 받아온다.
 upgrade : 설치된 패키지 중 'update'에 의해 발견된 새로운 버전이 있을 경우 업그레이드한다.
 install : <패키지>를 다운로드하여 설치한다.
 remove : <패키지>를 삭제한다. 하지만 사용자 데이터를 삭제하지는 않음.
 purge : <패키지>를 삭제하며 남아 있는 사용자 데이터 등도 전부 삭제한다.
 list : <매개변수>가 "--installed"인 경우, 설치된 패키지의 목록을 출력한다. <매개변수>가 "--upgradeable"인 경우, 설치된 패키지
중 upgrade(업그레이드)할 수 있는 패키지의 목록을 보여준다.

29. VI(VIM) 명령어 : 파일의 내용을 보거나 수정하기 위해 사용한다 ." vi <파일 경로>" 형식으로 사용한다.

30. NETSTAT(Network Statistics) 명령어 : 시스템의 네트워크 통계를 확인하기 위해 사용한다. "net-tools" 패키지를 설치해야 사용할 수 있다.

 * 일부 매개변수 *
 -n 혹은 --numeric : 호스트를 가능한 경우에도 도메인으로 표시하지 않고 실제 IP주소로, 포트를 숫자로 표시한다.
 -p 혹은 --program : 통신 중인 프로그램의 PID 및 이름을 표시한다. "sudo" 권한이 필요함.
 -l 혹은 --listening : 통신 단계가 대기(LISTENING) 중인 항목만 표시한다.
 -t : 통신 프로토콜이 TCP인 항목만 표시한다.
 
31. UFW(Ubuntu Firewall) 명령어 : 방화벽 설정을 변경하기 위해 사용한다. "ufw <매개변수?...>" 형식으로 사용한다.
 * 일부 매개변수 * 
 enable : 방화벽이 활성화된다. SSH 연결 중 실행 시 주의할 것.
 disable : 방화벽이 비활성화된다.
 reset : 방화벽에 등록된 모든 규칙을 제거하고 비활성화(Disable)한다.
 default <deny|allow> : 방화벽이 활성화되어 있는 상태에서, 등록된 규칙에 핕터되지 않는 연결을 어떻게 처리할 것인가에 대한 설정이다.
<deny>는 차단, <allow>는 허용.
 status <numbered?> : 현재 방화벽의 상태 및 규칙을 표시한다. <numbered> 매개변수를 부여할 경우 각 규칙에 번호를 부여하여 출력한다. 
 delete <n> : <ufw status numbered>에서 확인한 번호인 <n>에 해당하는 규칙을 삭제하낟.
 delete <allow|deny r> : <allow|deny r> 규칙에 해당하는 규칙을 삭제한다.
 allow <r> : <r> 규칙을 허용으로 추가한다.
 deny <r> : <r> 규칙을 거부로 추가한다.
 * 규칙 *
 ufw <allow|deny> <p> : 모든 접속자에 대해 포트 <p>번의 접속을 <허용|거부>한다. 가령, 모든 접속자에 대한 80번 포트 접근을 허용하려면 다음과
같이 명령한다. "ufw allow 80"
 ufw <allow|deny> <p>/<t> : 모든 접속자에 대해 포트 <p>번의 접속을 <t>프로토콜에 한해서 <허용|거부>한다. 가령, 모든 접속자에 대한 80번 포트
접근을 TCP 프로토콜로만 허용하려면 다음과 같이 명령한다. "ufw allow 80/tcp"
 ufw <allow|deny> proto <t> from <c> to <d> port <p> : 접속자 <c>가 로컬주소 <d>의 포트 <p>를 통하여 프로토콜 <t>로
접근하는 것을 <허용|거부>한다. 이 때 <c>는 CIDR 형식으로 작성한다. 로컬 주소 <d>는 특수한 경우가 아니면 "any"로 대체. 가령, 모든 접속자가 
포트 22를 통하여 프로토콜 TCP로 들어오는 연결을 허용하려면 다음과 같이 명령한다. "ufw allow proto tcp from 0.0.0.0/0 to any port 22"

32. ADDuser 명령어 : 사용자를 추가하기 위해 사용한다. "adduser <사용자 이름>" 형식으로 사용한다.

33. DELUSER(Delete user) 명령어 : 사용자를 제거하기 위해 사용한다. "deluser <매개변수?> <사용자 이름>" 형식으로 사용한다.
 * 일부 매개변수 *
 --remove-home : 홈 디렉토리를 함께 삭제한다.
 --remove-all-files : 해당 사용자와 관련된 모든 파일을 함께 삭제한다.

34. ADDGROUP 명령어 : 그룹을 추가하기 위해 사용한다. "addgroup <그룹 이름>" 형식으로 사용한다.

35. DeLGROUP(Delete Group) 명령어 : 그룹을 제거하기 위해 사용한다. "delgroup <그룹 이름>" 형식 혹은 "delgroup <사용자 이름> <그룹 이름>
"형식으로 사용한다. 전자는 <그룹 이름> 에 해당하는 그룹을 삭제하고, 후자는 <사용자 이름>에 해당하는 사용자를 <그룹 이름>에 해당하는 그룹으로 부터 
제외한다.

36. USERMOD(User Modification) 명령어 : 사용자를 수정하기 위해 사용한다. "usermod <매개변수?> <사용자 이름>" 형식으로 사용한다.
 
 * 일부 매개변수 * 
 -a : 사용자를 '-G' 매개변수에서 명시하는 그룹에 소속시킨다. 가령 "ubuntu" 사용자를 "secret" 그룹에 소속시키기 위해서는 다음과 같이 명령한다.
"usermod -aG secret ubuntu"

37. WGET (Web Get) 명령어 : 인터넷에 있는 리소스를 다운로드하기 위해 사용한다. "wget <매개변수?> <주소>" 형식으로 사용.
 * 일부 매개변수 *
 -b 혹은 --background : 다운로드 백그라운드에서 진행하여 다른 작업을 할 수 있게 해준다.
 -O 혹은 --output-document : 다운로드 받은 리소스가 저장될 파일 경로를 지정한다.

38. ZIP 명령어 : 파일 및 디렉토리를 압축하기 위해 사용한다. "zip <매개변수?> <압축 파일 경로> <압축 대상 경로...>" 형식으로 사용한다.
기본적으로 설치되어 있지 않음 으로 "sudo apt install zip"을 통해 설치가 필요하다.
 * 일부 매개변수 * 
 -e 혹은 --encrypt : 압축 파일에 비밀번호를 설정한다.
 
39. UNZIP 명령어 : ZIP 압축 파일을 해제하기 위해 사용한다. "unzip <매개변수?> <압축 파일 경로>" 형식으로 사용한다.

40. SERVICE 명령어 : 등록된 서비스를 관리하기 위해 사용한다. "service <서비스 이름> <명령>" 형식으로 사용한다. 가령, SSH서비스를 재시작하기 위해서는
다음과 같이 명령한다. "sudo service ssh restart"
 * 명령 *
 start : 앞에 명시한 <서비스 이름>에 해당하는 서비스를 시작한다.
 stop : 앞에 명시한 <서비스 이름>에 해당하는 서비스를 중지한다.
 restart : 앞에 명시한 <서비스 이름>에 해당하는 서비스를 재시작한다.
 status : 앞에 명시한 <서비스 이름>에 해당하는 서비스의 상태를 표시한다
 * 일부 매개변수 *
 --status-all : 모든 서비스의 상태를 표시한다. 이때 <서비스 이름> 및 <명령>을 적지 않는다. [ + ] 는 정상 실행(Active), [ - ] 중지중, [ ? ]
상태 정보를 제공하지 않거나 알 수 없는 경우.

41. CRONTAB 명령어 : 반복적으로 실행할 명령을 관리한다. "crontab <매개변수>" 형식으로 사용한다.
 * 일부 매개변수 * 
 -l : 현재 사용자의 Crontab 내용을 화면에 출력한다.
 -e : 현재 사용자의 Crontab 내용을 편집한다.
 -r : 현재 사용자의 Crontab 내용을 초기화한다.
 -u <사용자 이름> : 현재 사용자가 아닌, <사용자 이름>에 명시한 사용자의 Crontab에 대해 명령한다. 가령, "user1234" 사용자의 Crontab을 초기화하려면 
다음과 같이 명령한다. "sudo crontab -u user1234 -r"

42. KILL 명령어 : 프로세스를 종료시키기 위해 사용한다. "kill <매개변수?> <PID?>" 형식으로 사용한다. 이 때 <PID> 는 종료시키고자 하는 프로세스의 ID이다.
 * 일부 매개변수 * 
 -s <SIG> : 종료되는 프로세스에게 전달할 종료 신호.
 -L 혹은 --table : -s 매개변수의 <SIG>값에 사용 가능한 종료 신호들을 표로 정리하여 출력한다. 이 때 <PID>를 명시하지 않음

43. PS(Process) 명령어 : 현재 (나에 의해) 실행 중인 프로세스의 목록을 출력한다. "ps <매개변수?>" 형식으로 사용한다.
 * 일부 매개변수 * 
 -e 혹은 -A : 모든 프로세스 표시

44. IO Redirection : 입/출력의 방향을 재지정한다.
 44.1. 표준출력(Standard Output)(덮어쓰기) : 표준 출력 내용을 다른 파일로 향하도록 한다. "(명령) > (파일)"과 같이 명령하면 (명령)의 표준 출력 내용이 (파일)에 
덮어씌워진다. 가령 "netstat -nlt > n.txt"는 "netstat -nlt" 명령의 결과가 "n.txt" 파일에 저장된다.
 44.2. 표준출력(Standard Output) (이어쓰기) : 표준 출력 내용을 다른 파일로 향하도록 한다. "(명령) >> (파일)"과 같이 명령하면 (명령)의 표준 출력 내용이 (파일)
의 끝에 이어써진다. 가령 "netstat -nlt >> n.txt"는 "netstat -nlt" 명령의 결과가 "n.txt" 파일끝에 추가되어 저장된다.
 44.3. 표준 입력(Standard Input) : 파일을 명령에 대한 입력으로 향하도록 한다. "(명령) < (파일)"과 같이 명령하면 (파일)이 (명령)의 표준 입력이 된다. 가령 "cat
< memo.txt" 명령은 "memo.txt" 파일 내용을 화면에 출력한다.
 44.4. 표준 오류(Standard Error) : 용법이나 내용은 표준 출력과 동일하나 출력 내용 중 오류만 다른 파일로 향하도록 한다. "(명령) 2> (파일)"과 같이 명령한다.
 44.5. 표준 출력 + 표준 오류 : &> 

45. Pipe : 어떠한 명령의 출력을 또 다른 명령의 입력으로 사용하기 위해 사용한다. "<A 명령>|<B 명령>"의 형태에서 <A 명령>에 의한 출력을 <B 명령>의 입력으로 사용한다.]
 예시 : grep '?' ' ' 참조 : https://coding-factory.tistory.com/802

46. 












